//todo Задание 1 (тайминг 10 минут)
//  1. Начинаем реализацию хэш-таблицы с подготовки структуры и необходимых классов.
//  2. Давайте напишем реализацию односвязного списка, в котором мы и будем хранить пары ключ-значение.
//  3. Стоит обратить внимание, что можно использовать как дженерики, для обобщения возможных типов ключей и значений,
//      так и заранее определить для себя конкретные типы, которые будут использоваться в качестве ключа и значения.
//      Оба подхода допустимы для реализации.

//todo Задание 2 (тайминг 15 минут)
//  1. Добавляем массив связных списков с фиксированным размером (массив бакетов), либо передаваемым в конструкторе.
//  2. Хэш-таблица оперирует индексами, потому массив будет идеальным вариантов для представления бакетов.
//  3. Также реализуем метод вычисления индекса на основании хэш-кода ключа.

// todo Задание 3 (тайминг 10 минут)
//  1. Реализуем метод поиска данных по ключу в хэш-таблице.
//  2. Теперь, когда у нас есть базовая структура нашей хэш-таблицы, можно написать алгоритм поиска элементов,
//      включающий в себя поиск нужного бакета и поиск по бакету.

//todo Задание 4 (тайминг 15 минут)
//  1. Необходимо реализовать методы добавления элементов в связный список, если там еще нет пары
//      с аналогичным ключом и удаления элемента с аналогичным ключом из списка.
//  2. Все значения ключей в хэш-таблице уникальны, а значит и в каждом из связных список это правило
//      будет также выполняться.

//todo Задание 5 (тайминг 5 минут)
//  1. Реализуем алгоритм добавления и удаления элементов из хэш-таблицы по ключу.

//todo Задание 6 (тайминг 15 минут)
//  1. Добавляем информацию о размере хэш-таблицы, а также алгоритм увеличения количества бакетов
//      при достижении количества элементов до определенного размера относительно количества бакетов (load factor).
//  2. Чтобы хэш-таблица сохраняла сложность поиска близкой к O(1), нам необходимо контролировать количество бакетов,
//      чтобы в них не скапливалось слишком много элементов, которые способны увеличить длительность операции
//      поиска и добавления.
//  3. В Java load factor для хэш-таблицы – 0.75, что значит, что при достижении количества значений 75%
//      от общего количества бакетов – это количество необходимо увеличить. Это позволяет минимизировать шансы, что в
//      бакетах будет больше 1-2 значений, а значит сохранит скорость поиска на уровне сложности O(1).

//todo Задание 7 (тайминг 10 минут)
//  1. Реализуем структуру бинарного дерева.
//  2. Для бинарного дерева характерно наличии двух потомков, где левый меньше родителя, а правый – больше.
//  3. Для реализации можно использовать как и простое числовое дерево, так и обобщенный тип.
//      Учитывая, что мы строим именно бинарное дерево, то при использовании обобщенных типов убедитесь, что значение
//      поддерживает сравнение (интерфейс Comparable)

//todo Задание 8 (тайминг 15 минут)
//  1. Реализуем алгоритм поиска элементов по дереву (поиск в глубину).
//  2. Для работы с бинарным деревом необходимо как минимум организовать метод поиска.

//todo Домашнее задание
//  1. Необходимо превратить собранное на семинаре дерево поиска в полноценное левостороннее красно-черное дерево.
//      И реализовать в нем метод добавления новых элементов с балансировкой.
//  2. Красно-черное дерево имеет следующие критерии:
//      ● Каждая нода имеет цвет (красный или черный)
//      ● Корень дерева всегда черный
//      ● Новая нода всегда красная
//      ● Красные ноды могут быть только левым ребенком
//      ● У красной ноды все дети черного цвета
//  3. Соответственно, чтобы данные условия выполнялись, после добавления элемента в дерево необходимо произвести
//      балансировку, благодаря которой все критерии выше станут валидными.
//  4. Для балансировки существует 3 операции – левый малый поворот, правый малый поворот и смена цвета.
//  Критерии применения этих операций следующие:
//      ● Если правый ребенок – красный, а левый - черный, то применяем малый правый поворот
//      ● Если левый ребенок красный и его левый ребенок тоже красный – применяем малый левый поворот
//      ● Если оба ребенка красные – делаем смену цвета
//      ● Если корень стал красным – просто перекрашиваем его в черный

import task123456.HashTable;
import task78.BinTree;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        HashTable<Integer, String> hashTable = new HashTable<>(4);

//        System.out.println(hashTable.add(123, "Сто двадцать три"));
//        System.out.println(hashTable.add(124, "Сто двадцать четыре"));
//        System.out.println(hashTable);
//        System.out.println(hashTable.add(125, "Сто двадцать пять"));
//        System.out.println(hashTable.add(14, "Четырнадцать"));
//        System.out.println(hashTable.add(15, "Четырнадцать"));
//        System.out.println(hashTable.add(14, "ldskfl"));
//        System.out.println(hashTable);
//        System.out.println(hashTable.add(16, "Шестнадцать"));
//        System.out.println(hashTable.add(17, "Семнадцать"));
//
//        System.out.println(hashTable);
//        System.out.println(hashTable.getValue(123));
//
//        System.out.println(hashTable.deleteByValue("Четырнадцать"));
//        System.out.println(hashTable);
//
//        System.out.println(hashTable.deleteByKey(124));
//        System.out.println(hashTable);

//        HashTable<Character, String> hashTable1 = new HashTable<>();
//        hashTable1.add('а', "Прописная первая буква алфавита");
//        hashTable1.add('А', "Заглавная первая буква алфавита");
//        System.out.println(hashTable1);
//        hashTable1.deleteByKey('а');
//        System.out.println(hashTable1);

//        int i = 0;
//        do {
//            hashTable.add(i, "Number " + i);
//            i++;
//            System.out.println(hashTable);
//        } while (getAnswer());

        BinTree<Integer> tree = new BinTree<>();
        tree.add(5);
        tree.add(10);
        tree.add(1);
        tree.add(6);

        System.out.println(tree.find(7));
    }


    public static boolean getAnswer() {
        Scanner scanner = new Scanner(System.in);

        System.out.println("Again?");
        return switch (scanner.nextLine().charAt(0)) {
            case 'y', 'Y', 'д', 'Д' -> Boolean.TRUE;
            default -> Boolean.FALSE;
        };
    }
}